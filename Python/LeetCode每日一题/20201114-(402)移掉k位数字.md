### 题目描述

给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。

注意:

num 的长度小于 10002 且 ≥ k。
num 不会包含任何前导零。

示例 1 :

输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。

示例 2 :

输入: num = "10200", k = 1
输出: "200"
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。

示例 3 :

输入: num = "10", k = 2
输出: "0"
解释: 从原数字移除所有的数字，剩余为空就是0。

#### 第一次思路：

自己考虑记录一下各个数字出现的位置和次数，然后从左向右（从高位到低位）选择数字。

一个小时无果，错误的思路。

#### 直接看答案

给定一个长度为 
n
 的数字序列 
[
D
0
D
1
D
2
D
3
…
D
n
−
1
]
，从左往右找到第一个位置 
i
（i>0）使得 
D
i
<
D
i
−
1
，并删去 
D
i
−
1
；如果不存在，说明整个数字序列单调不降，删去最后一个数字即可。基于此，我们可以每次对整个数字序列执行一次这个策略；删去一个字符后，剩下的 
n−1 长度的数字序列就形成了新的子问题，可以继续使用同样的策略，直至删除 
k
次。

我们可以用一个栈维护当前的答案序列，栈中的元素代表截止到当前位置，删除不超过 
k
k 次个数字后，所能得到的最小整数。根据之前的讨论：在使用 
k
k 个删除次数之前，栈中的序列从栈底到栈顶单调不降。因此，对于每个数字，如果该数字小于栈顶元素，我们就不断地弹出栈顶元素，直到：

栈为空
或者 新的栈顶元素不大于当前数字 或者 我们已经删除了 
k
 位数字。

上述步骤结束后我们还需要针对一些情况做额外的处理：

如果我们删除了 

m 个数字且 
m
<
k
，这种情况下我们需要从序列尾部删除额外的 
k−m 个数字。
如果最终的数字序列存在前导零，我们要删去前导零。
如果最终数字序列为空，我们应该返回 
0。
最终，从栈底到栈顶的答案序列即为最小数。

考虑到栈的特点是后进先出，如果通过栈实现，则需要将栈内元素依次弹出然后进行翻转才能得到最小数。为了避免翻转操作，可以使用双端队列代替栈的实现。

看完答案后，自己仿照答案写法写了一遍如下：

```c

char * removeKdigits(char * num, int k){
    int length = strlen(num);
    int i,top = 0;
    char * stack = (char *)malloc(sizeof(char)* (length+1));
    for(i = 0; i < length; i++){
        while(top > 0 && stack[top] >num[i] && k){
            top--;
            k--;
        }
        stack[++top] = num[i];
    }
    top -= k;

    char * ans = (char*)malloc(sizeof(char) * (length + 1));
    int ansSize = 0;
    bool leadbyzero = true;
    for(i = 1; i <= top; i++){
        if(stack[i] == '0' && leadbyzero){
            continue;
        }
        leadbyzero = false;
        ans[ansSize++] = stack[i];
    }

    if(ansSize == 0){
        ans[0] = '0';
        ans[1] = 0;
    }else{
        ans[ansSize] = 0;
    }

    return ans;
}

```

